// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: task.sql

package sqlc

import (
	"context"
)

const taskCreate = `-- name: TaskCreate :exec
INSERT INTO task (uid, name, active, "type")
VALUES ($1, $2, $3, $4)
`

type TaskCreateParams struct {
	Uid    string
	Name   string
	Active bool
	Type   TaskType
}

func (q *Queries) TaskCreate(ctx context.Context, arg TaskCreateParams) error {
	_, err := q.db.Exec(ctx, taskCreate,
		arg.Uid,
		arg.Name,
		arg.Active,
		arg.Type,
	)
	return err
}

const taskGetByUID = `-- name: TaskGetByUID :one
SELECT uid, name, active, type
FROM task
WHERE uid = $1
`

func (q *Queries) TaskGetByUID(ctx context.Context, uid string) (Task, error) {
	row := q.db.QueryRow(ctx, taskGetByUID, uid)
	var i Task
	err := row.Scan(
		&i.Uid,
		&i.Name,
		&i.Active,
		&i.Type,
	)
	return i, err
}

const taskGetFiltered = `-- name: TaskGetFiltered :many
SELECT t.uid, t.name, t.active, t.type, r.id, r.task_uid, r.run_at, r.result, r.error, r.duration
FROM task_run r
LEFT JOIN task t ON t.uid = r.task_uid
WHERE
  (t.uid = $1 OR NOT $5) AND
  (r.result = $2 OR NOT $6) AND
  t.active
ORDER BY r.run_at DESC
LIMIT $3 OFFSET $4
`

type TaskGetFilteredParams struct {
	Uid           string
	Result        TaskResult
	Limit         int32
	Offset        int32
	FilterTaskUid interface{}
	FilterResult  interface{}
}

type TaskGetFilteredRow struct {
	Task    Task
	TaskRun TaskRun
}

func (q *Queries) TaskGetFiltered(ctx context.Context, arg TaskGetFilteredParams) ([]TaskGetFilteredRow, error) {
	rows, err := q.db.Query(ctx, taskGetFiltered,
		arg.Uid,
		arg.Result,
		arg.Limit,
		arg.Offset,
		arg.FilterTaskUid,
		arg.FilterResult,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TaskGetFilteredRow
	for rows.Next() {
		var i TaskGetFilteredRow
		if err := rows.Scan(
			&i.Task.Uid,
			&i.Task.Name,
			&i.Task.Active,
			&i.Task.Type,
			&i.TaskRun.ID,
			&i.TaskRun.TaskUid,
			&i.TaskRun.RunAt,
			&i.TaskRun.Result,
			&i.TaskRun.Error,
			&i.TaskRun.Duration,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const taskRunGet = `-- name: TaskRunGet :one
SELECT t.uid, t.name, t.active, t.type, r.id, r.task_uid, r.run_at, r.result, r.error, r.duration
FROM task_run r
LEFT JOIN task t ON t.uid = r.task_uid
WHERE r.id = $1
`

type TaskRunGetRow struct {
	Task    Task
	TaskRun TaskRun
}

func (q *Queries) TaskRunGet(ctx context.Context, id int32) (TaskRunGetRow, error) {
	row := q.db.QueryRow(ctx, taskRunGet, id)
	var i TaskRunGetRow
	err := row.Scan(
		&i.Task.Uid,
		&i.Task.Name,
		&i.Task.Active,
		&i.Task.Type,
		&i.TaskRun.ID,
		&i.TaskRun.TaskUid,
		&i.TaskRun.RunAt,
		&i.TaskRun.Result,
		&i.TaskRun.Error,
		&i.TaskRun.Duration,
	)
	return i, err
}

const taskSetInactiveRecurring = `-- name: TaskSetInactiveRecurring :exec
UPDATE task
SET active = false
WHERE "type" = 'recurring'
`

func (q *Queries) TaskSetInactiveRecurring(ctx context.Context) error {
	_, err := q.db.Exec(ctx, taskSetInactiveRecurring)
	return err
}

const taskUpdate = `-- name: TaskUpdate :exec
UPDATE task
SET name = $2, active = $3
WHERE uid = $1
`

type TaskUpdateParams struct {
	Uid    string
	Name   string
	Active bool
}

func (q *Queries) TaskUpdate(ctx context.Context, arg TaskUpdateParams) error {
	_, err := q.db.Exec(ctx, taskUpdate, arg.Uid, arg.Name, arg.Active)
	return err
}
